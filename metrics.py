import predict
import numpy as np
import table_data
import tensorflow as tf

# images path
IMAGES_GCS_PATH = 'gs://osic_fibrosis/images-hue/images-hue'

# image size
IMAGE_SIZE = (224, 224)


def laplace_log_likelihood(y_true, y_pred, theta):
    """Compute the Laplace Lop Likelihood score for the predictions y_pred.
    Args:
        y_true-ground truth values
        y_pred-predicted values
        theta-confidence measurements
    """

    theta_clipped = np.clip(theta, 70, None)
    delta = np.clip(np.abs(y_true - y_pred), 0, 1000)
    metric = - (np.sqrt(2) * delta) / theta_clipped - np.log(np.sqrt(2) * theta_clipped)
    return metric.sum() / len(y_true)


def get_lll_value_exp_function(id, exp_function, theta=200):
    """Return the laplace log likelihood score for a given patient and his exponent function."""
    hist = table_data.get_fvc_hist(table_data.get_train_table(), id)  # get ground truth

    # initiate predictions
    y_pred = []

    # get predictions
    for week in np.array(hist["Weeks"]):
        week = float(week)
        pred = exp_function(week)  # predict
        y_pred.append(pred)

    y_pred = np.array(y_pred)
    y_true = hist["FVC"]

    # compute_metric
    metric = laplace_log_likelihood(y_true, y_pred, theta)
    return metric


def metric_check(exp_gen=None, n_patients=5, infinite=False):
    """Average n_patients random train patients Laplace Log Likelihood score for predictions generated by exp_gen.
    Args:
        exp_gen-generator yeilding id and exponent function for that id
        n_patients-number of patients to average
        infinite-whether to continue printing infinitely
    """

    scores = []

    if not exp_gen:
        exp_gen = predict.exponent_generator(IMAGES_GCS_PATH + '/train')

    # get scores
    for i, (id, func) in enumerate(exp_gen):
        score = get_lll_value_exp_function(id, func)
        scores.append(score)

        # exit rule
        if infinite:
            print(score) # for infinitely printing scores
        else:
            if i == n_patients - 1:
                break

    return sum(scores) / n_patients


# This section is taken from 'https://www.kaggle.com/chrisden/6-82-quantile-reg-lr-schedulers-checkpoints'
# I don't know who created the original kernel so I thank 'from coffee import *'
# from kaggle at https://www.kaggle.com/chrisden' from whom I copied this...

def score(y_true, y_pred):
    """Calculate the competition metric"""
    # create constants for the loss function
    C1, C2 = tf.constant(70, dtype='float32'), tf.constant(1000, dtype="float32")

    # cast dtypes
    tf.dtypes.cast(y_true, tf.float32)
    tf.dtypes.cast(y_pred, tf.float32)

    # compute sigma as the difference betwwen the marginal quantiles divided by 2
    sigma = (y_pred[:, 2] - y_pred[:, 0])
    sigma_clip = tf.maximum(sigma, C1)

    # compute fvc as the median quantile
    fvc_pred = y_pred[:, 1]

    # compute delta as the error between ground truth and the computed median
    delta = tf.abs(y_true[:, 0] - fvc_pred)
    delta = tf.minimum(delta, C2)

    # compute metric
    sq2 = tf.sqrt(tf.dtypes.cast(2, dtype=tf.float32))
    metric = (delta / sigma_clip) * sq2 + tf.math.log(sigma_clip * sq2)

    return tf.keras.backend.mean(metric)


def qloss(y_true, y_pred):
    """Calculate Pinball loss"""
    # IMPORTANT: define quartiles, feel free to change here!
    qs = [0.2, 0.50, 0.8]
    q = tf.constant(np.array([qs]), dtype=tf.float32)
    e = y_true - y_pred
    v = tf.maximum(q * e, (q - 1) * e)
    return tf.keras.backend.mean(v)


def mloss(_lambda):
    """Combine Score and qloss.
    Args:
        _lambda: weighting constant for how much competition metric should be in the loss functio.
                 higher _lambda -> lower weight for the competition metric
    """

    def loss(y_true, y_pred):
        return _lambda * qloss(y_true, y_pred) + (1 - _lambda) * score(y_true, y_pred)

    return loss


if __name__ == "__main__":
    exp_gen = predict.exponent_generator(IMAGES_GCS_PATH + '/validation', model_path='models_weights/cnn_model/model_v3.ckpt')
    print(metric_check(exp_gen=exp_gen, n_patients=14))