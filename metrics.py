import predict
import numpy as np
import table_data

# images path
IMAGES_GCS_PATH = 'gs://osic_fibrosis/images-norm/images-norm'

# image size
IMAGE_SIZE = (224, 224)


def laplace_log_likelihood(y_true, y_pred, theta):
    """Compute the Laplace Lop Likelihood score for the predictions y_pred.
    Args:
        y_true-ground truth values
        y_pred-predicted values
        theta-confidence measurements
    """

    theta_clipped = np.clip(theta, 70, None)
    delta = np.clip(np.abs(y_true - y_pred), 0, 1000)
    metric = - (np.sqrt(2) * delta) / theta_clipped - np.log(np.sqrt(2) * theta_clipped)
    return metric.sum() / len(y_true)


def get_lll_value_exp_function(id, exp_function, theta=200):
    """Return the laplace log likelihood score for a given patient and his exponent function."""
    hist = table_data.get_fvc_hist(table_data.get_train_table(), id)  # get ground truth

    # initiate predictions
    y_pred = []

    # get predictions
    for week in np.array(hist["Weeks"]):
        week = float(week)
        pred = exp_function(week)  # predict
        y_pred.append(pred)

    y_pred = np.array(y_pred)
    y_true = hist["FVC"]

    # compute_metric
    metric = laplace_log_likelihood(y_true, y_pred, theta)
    return metric


def metric_check(exp_gen, n_patients, infinite=False):
    """Average n_patients random train patients Laplace Log Likelihood score for predictions generated by exp_gen.
    Args:
        exp_gen-generator yeilding id and exponent function for that id
        n_patients-number of patients to average
        infinite-whether to continue printing infinitely
    """

    scores = []

    if not exp_gen:
        exp_gen = predict.exponent_generator(IMAGES_GCS_PATH + '/train')

    # get scores
    for i, (id, func) in enumerate(exp_gen):
        score = get_lll_value_exp_function(id, func)
        scores.append(score)

        # exit rule
        if infinite:
            print(score) # for infinitely printing scores
        else:
            if i == n_patients - 1:
                break

    return sum(scores) / n_patients



